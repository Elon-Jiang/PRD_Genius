
import React, { useState, useEffect, useRef } from 'react';
import { Plus, Trash2, ArrowRight, Square, Diamond, Box, Link as LinkIcon, AlertCircle } from 'lucide-react';

interface VisualFlowchartEditorProps {
  mermaidCode: string;
  onChange: (newCode: string) => void;
}

interface FlowNode {
  id: string;
  label: string;
  type: 'process' | 'decision';
}

interface FlowLink {
  id: string; // internal temp id for list management
  source: string;
  target: string;
  label: string;
  type: 'solid' | 'dotted' | 'thick';
}

const VisualFlowchartEditor: React.FC<VisualFlowchartEditorProps> = ({ mermaidCode, onChange }) => {
  const [activeTab, setActiveTab] = useState<'nodes' | 'links'>('nodes');
  const [nodes, setNodes] = useState<FlowNode[]>([]);
  const [links, setLinks] = useState<FlowLink[]>([]);
  const [parseError, setParseError] = useState<string | null>(null);

  // Ref to track the last code WE generated. 
  // Initialize to null so the first pass (mount) ALWAYS parses the incoming code.
  const lastGeneratedCode = useRef<string | null>(null);

  // --- Parser ---
  useEffect(() => {
    // Prevent sync loop: If code matches what we just output, ignore it.
    if (mermaidCode === lastGeneratedCode.current) {
        return;
    }

    try {
      const lines = mermaidCode.split('\n')
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('graph') && !l.startsWith('%%') && !l.startsWith('subgraph') && !l.startsWith('end'));

      const nodeMap = new Map<string, FlowNode>();
      const linkList: FlowLink[] = [];

      const parseNode = (str: string): FlowNode => {
        // Matches: ID, ID[Label], ID{Label}, ID("Label")
        const match = str.match(/^([a-zA-Z0-9_]+)(\s*([\[\{\(])"*([^"\}\]\)]+)"*([\]\}\)]))?/);
        if (match) {
            const id = match[1];
            const shape = match[3];
            let label = match[4] || id;
            label = label.replace(/^"|"$/g, ''); // cleanup quotes
            const type = shape === '{' ? 'decision' : 'process';
            return { id, label, type };
        }
        // Fallback for simple ID
        const cleanStr = str.replace(/["\s\[\]\{\}\(\)]/g, '');
        if (!cleanStr) return { id: `Node_${Math.random().toString(36).substr(2,5)}`, label: 'Unknown', type: 'process' };
        return { id: cleanStr, label: cleanStr, type: 'process' };
      };

      // Arrow definitions to look for, order matters (longest match first)
      const arrowTypes = [
          { pattern: '==>', type: 'thick' },
          { pattern: '-.->', type: 'dotted' },
          { pattern: '-->', type: 'solid' },
          { pattern: '---', type: 'solid' }
      ];

      lines.forEach(line => {
        let foundLink = false;

        // Try to find a link
        for (const arrow of arrowTypes) {
            if (line.includes(arrow.pattern)) {
                // Split by the arrow pattern first
                // Need to handle labels like -->|Text| or -- Text -->
                // Simple split might fail if label contains the arrow chars, but unlikely in valid mermaid for these basic types
                
                // Regex to capture: (Source) (Arrow+Label) (Target)
                // Note: This is a simplified parser. 
                // It looks for the arrow symbol in the line.
                
                const parts = line.split(arrow.pattern);
                if (parts.length >= 2) {
                    const sourcePart = parts[0].trim();
                    // The target is the last part, but intermediate parts might be labels if split incorrectly? 
                    // Usually lines are "A --> B", so split gives 2 parts.
                    // If "A --> B --> C", this parser splits into 3. 
                    // Let's assume one link per line for safety as generated by our AI.
                    
                    let targetPart = parts.slice(1).join(arrow.pattern).trim(); // Rejoin rest
                    let label = '';
                    let linkType: 'solid' | 'dotted' | 'thick' = arrow.type as any;

                    // Check for label syntax: |Label| at start of target, or -- Label -- at end of source?
                    // Standard Mermaid: A -->|Label| B
                    if (targetPart.startsWith('|')) {
                        const labelEnd = targetPart.indexOf('|', 1);
                        if (labelEnd > -1) {
                            label = targetPart.substring(1, labelEnd);
                            targetPart = targetPart.substring(labelEnd + 1).trim();
                        }
                    } 
                    // Alternate Mermaid: A -- Label --> B
                    // In this case, the arrow pattern might have matched the "-->" at the end.
                    // The source part might end with "-- Label".
                    else if (sourcePart.includes('--')) {
                        // This logic is tricky with split. Let's stick to the AI's preferred output format which is usually |Label| or simple arrows.
                    }

                    const srcNode = parseNode(sourcePart);
                    const tgtNode = parseNode(targetPart);

                    if (srcNode.id && tgtNode.id) {
                        // Register Nodes
                        if (!nodeMap.has(srcNode.id)) nodeMap.set(srcNode.id, srcNode);
                        else {
                            // Keep existing type if already set to decision
                            const existing = nodeMap.get(srcNode.id)!;
                            if (srcNode.type === 'decision') existing.type = 'decision';
                            if (srcNode.label !== srcNode.id) existing.label = srcNode.label;
                        }

                        if (!nodeMap.has(tgtNode.id)) nodeMap.set(tgtNode.id, tgtNode);
                        else {
                            const existing = nodeMap.get(tgtNode.id)!;
                            if (tgtNode.type === 'decision') existing.type = 'decision';
                            if (tgtNode.label !== tgtNode.id) existing.label = tgtNode.label;
                        }

                        // Register Link
                        linkList.push({
                            id: `Link_${Math.random().toString(36).substr(2, 6)}`,
                            source: srcNode.id,
                            target: tgtNode.id,
                            label,
                            type: linkType
                        });
                        foundLink = true;
                    }
                }
                break; // Stop after first match found
            }
        }

        if (!foundLink) {
             // Single Node Definition line
             const n = parseNode(line);
             if (n.id && !nodeMap.has(n.id)) {
                 nodeMap.set(n.id, n);
             }
        }
      });

      setNodes(Array.from(nodeMap.values()));
      setLinks(linkList);
      setParseError(null);
    } catch (e) {
      console.error("Parse error", e);
      setParseError("部分代码无法解析，建议在代码模式下查看。");
    }
  }, [mermaidCode]); 

  // --- Generator ---
  const updateCode = (newNodes: FlowNode[], newLinks: FlowLink[]) => {
    let code = 'graph TD\n';
    
    // 1. Write Nodes definitions
    newNodes.forEach(n => {
        // Sanitize label
        const safeLabel = n.label.replace(/"/g, "'"); 
        if (n.type === 'decision') code += `  ${n.id}{"${safeLabel}"}\n`;
        else code += `  ${n.id}["${safeLabel}"]\n`;
    });
    
    code += '\n';

    // 2. Write Links
    newLinks.forEach(l => {
        let arrow = '-->';
        if (l.type === 'dotted') arrow = '-.->';
        if (l.type === 'thick') arrow = '==>';
        
        // Add spaces around arrows to ensure parser reliability
        if (l.label) {
            // Use |Label| syntax which is robust
            code += `  ${l.source} ${arrow}|${l.label.replace(/"/g, "'")}| ${l.target}\n`;
        } else {
            code += `  ${l.source} ${arrow} ${l.target}\n`;
        }
    });

    // Update the ref so the useEffect knows this change came from us
    lastGeneratedCode.current = code;
    onChange(code);
  };

  // --- Actions ---
  const handleAddNode = () => {
    const id = `Node_${Date.now()}`;
    const newNode: FlowNode = { id, label: '新节点', type: 'process' };
    const updatedNodes = [...nodes, newNode];
    setNodes(updatedNodes);
    updateCode(updatedNodes, links);
  };

  const handleUpdateNode = (id: string, field: keyof FlowNode, value: string) => {
    const updatedNodes = nodes.map(n => n.id === id ? { ...n, [field]: value } : n);
    setNodes(updatedNodes);
    updateCode(updatedNodes, links);
  };

  const handleDeleteNode = (id: string) => {
    const updatedNodes = nodes.filter(n => n.id !== id);
    const updatedLinks = links.filter(l => l.source !== id && l.target !== id);
    setNodes(updatedNodes);
    setLinks(updatedLinks);
    updateCode(updatedNodes, updatedLinks);
  };

  const handleAddLink = () => {
    if (nodes.length < 2) return;
    const newLink: FlowLink = {
        id: `Link_${Date.now()}`,
        source: nodes[nodes.length-2].id,
        target: nodes[nodes.length-1].id,
        label: '',
        type: 'solid'
    };
    const updatedLinks = [...links, newLink];
    setLinks(updatedLinks);
    updateCode(nodes, updatedLinks);
  };

  const handleUpdateLink = (id: string, field: keyof FlowLink, value: string) => {
    const updatedLinks = links.map(l => l.id === id ? { ...l, [field]: value } : l);
    setLinks(updatedLinks);
    updateCode(nodes, updatedLinks);
  };

  const handleDeleteLink = (id: string) => {
    const updatedLinks = links.filter(l => l.id !== id);
    setLinks(updatedLinks);
    updateCode(nodes, updatedLinks);
  };

  return (
    <div className="flex flex-col h-full bg-slate-50 border-r border-slate-200">
      {/* Tabs */}
      <div className="flex border-b border-slate-200 bg-white shrink-0">
        <button
          onClick={() => setActiveTab('nodes')}
          className={`flex-1 py-3 text-sm font-medium flex items-center justify-center gap-2 border-b-2 transition-colors ${
            activeTab === 'nodes' ? 'border-blue-500 text-blue-600' : 'border-transparent text-slate-500 hover:text-slate-700'
          }`}
        >
          <Box size={16} /> 节点 ({nodes.length})
        </button>
        <button
          onClick={() => setActiveTab('links')}
          className={`flex-1 py-3 text-sm font-medium flex items-center justify-center gap-2 border-b-2 transition-colors ${
            activeTab === 'links' ? 'border-blue-500 text-blue-600' : 'border-transparent text-slate-500 hover:text-slate-700'
          }`}
        >
          <LinkIcon size={16} /> 连线 ({links.length})
        </button>
      </div>

      <div className="flex-1 overflow-y-auto custom-scroll p-4">
        {parseError && (
            <div className="bg-amber-50 text-amber-600 p-3 rounded-lg text-xs mb-4 flex items-start gap-2">
                <AlertCircle size={14} className="mt-0.5" />
                <span>{parseError}</span>
            </div>
        )}

        {/* NODES TAB */}
        {activeTab === 'nodes' && (
          <div className="space-y-3">
             {nodes.map((node) => (
                <div key={node.id} className="bg-white p-3 rounded-lg border border-slate-200 shadow-sm flex items-center gap-2 group animate-in fade-in slide-in-from-bottom-2 duration-300">
                   
                   {/* Type Toggle */}
                   <button 
                     onClick={() => handleUpdateNode(node.id, 'type', node.type === 'process' ? 'decision' : 'process')}
                     className={`p-1.5 rounded border transition-colors shrink-0 ${
                        node.type === 'decision' 
                        ? 'bg-amber-50 border-amber-200 text-amber-600' 
                        : 'bg-blue-50 border-blue-200 text-blue-600'
                     }`}
                     title={node.type === 'decision' ? '点击切换为：流程节点' : '点击切换为：判断节点'}
                   >
                     {node.type === 'decision' ? <Diamond size={14} /> : <Square size={14} />}
                   </button>

                   {/* Label Input */}
                   <input 
                     className="flex-1 text-sm border-slate-200 bg-slate-50 rounded px-2 py-1 focus:bg-white focus:ring-2 focus:ring-blue-100 focus:border-blue-300 outline-none transition-all w-full min-w-0"
                     value={node.label}
                     onChange={(e) => handleUpdateNode(node.id, 'label', e.target.value)}
                     placeholder="输入节点名称..."
                   />

                   <div className="shrink-0 text-slate-300 font-mono text-[10px] w-12 truncate text-right pointer-events-none" title={node.id}>
                      {node.id}
                   </div>

                   {/* Delete */}
                   <button 
                     onClick={() => handleDeleteNode(node.id)}
                     className="p-1.5 text-slate-300 hover:text-red-500 hover:bg-red-50 rounded transition-colors shrink-0"
                     title="删除节点"
                   >
                     <Trash2 size={14} />
                   </button>
                </div>
             ))}
             
             <button 
               onClick={handleAddNode}
               className="w-full py-3 border-2 border-dashed border-slate-200 rounded-lg text-slate-500 hover:border-blue-400 hover:text-blue-600 hover:bg-blue-50 transition-all flex items-center justify-center gap-2 text-sm font-medium"
             >
               <Plus size={16} /> 添加新节点
             </button>
          </div>
        )}

        {/* LINKS TAB */}
        {activeTab === 'links' && (
          <div className="space-y-3">
             {links.map((link) => (
               <div key={link.id} className="bg-white p-3 rounded-lg border border-slate-200 shadow-sm flex flex-col gap-3 group animate-in fade-in slide-in-from-bottom-2 duration-300">
                  <div className="flex items-center gap-2">
                      {/* Source */}
                      <select 
                        className="flex-1 text-xs border-slate-200 rounded px-2 py-1.5 bg-slate-50 focus:ring-2 focus:ring-blue-100 focus:border-blue-300 outline-none truncate"
                        value={link.source}
                        onChange={(e) => handleUpdateLink(link.id, 'source', e.target.value)}
                      >
                         {nodes.map(n => <option key={n.id} value={n.id}>{n.label.substring(0,20)}</option>)}
                      </select>

                      {/* Arrow Type */}
                      <div className="text-slate-400 shrink-0">
                         <ArrowRight size={14} />
                      </div>

                      {/* Target */}
                      <select 
                        className="flex-1 text-xs border-slate-200 rounded px-2 py-1.5 bg-slate-50 focus:ring-2 focus:ring-blue-100 focus:border-blue-300 outline-none truncate"
                        value={link.target}
                        onChange={(e) => handleUpdateLink(link.id, 'target', e.target.value)}
                      >
                         {nodes.map(n => <option key={n.id} value={n.id}>{n.label.substring(0,20)}</option>)}
                      </select>
                      
                      <button 
                        onClick={() => handleDeleteLink(link.id)}
                        className="p-1.5 text-slate-300 hover:text-red-500 hover:bg-red-50 rounded transition-colors ml-1 shrink-0"
                      >
                        <Trash2 size={14} />
                      </button>
                  </div>

                  <div className="flex items-center gap-2 pl-2 border-l-2 border-slate-100">
                     <span className="text-xs text-slate-400 shrink-0">连线:</span>
                     <input 
                       className="flex-1 text-xs border-slate-200 rounded px-2 py-1 focus:ring-1 focus:ring-blue-100 focus:border-blue-300 outline-none w-full min-w-0"
                       value={link.label}
                       onChange={(e) => handleUpdateLink(link.id, 'label', e.target.value)}
                       placeholder="描述..."
                     />
                     <select 
                       className="text-xs border-slate-200 rounded px-1 py-1 bg-white shrink-0"
                       value={link.type}
                       onChange={(e) => handleUpdateLink(link.id, 'type', e.target.value as any)}
                     >
                        <option value="solid">实线</option>
                        <option value="dotted">虚线</option>
                        <option value="thick">粗线</option>
                     </select>
                  </div>
               </div>
             ))}

             <button 
               onClick={handleAddLink}
               className="w-full py-3 border-2 border-dashed border-slate-200 rounded-lg text-slate-500 hover:border-blue-400 hover:text-blue-600 hover:bg-blue-50 transition-all flex items-center justify-center gap-2 text-sm font-medium"
             >
               <Plus size={16} /> 添加新连线
             </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default VisualFlowchartEditor;
